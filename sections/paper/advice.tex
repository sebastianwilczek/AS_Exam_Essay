\section{Advice}

Speaking in technical terms, \ac{BLE} could be called a secure communications protocol. Especially specification 4.2 introduces pairing processes and methods to ensure that passive eavesdropping and MITM attacks become less feasible. However, as it is often the case, the implementation often causes security concerns.

If \ac{BLE} is to be fully secured, all Legacy communications, as in communications not implementing specification 4.2 and above, have to be discouraged from being made use of. Specification 4.0 and 4.1 are highly susceptible to even simple eavesdropping techniques and should not be used for any form of secure communication between Bluetooth devices. On a legislative level, it may be possible to ensure that products not adhering to specification 4.2 are not allowed to reach the public market or that devices that do not adhere are appropriately marked as insecure.

The current biggest flaw in \ac{BLE} is key exchange. Specification 4.2 improved on this by introducing public key infrastructure. However, given the specification, there is no requirement to actually adhere to these. For example, it is entirely possible to use static Diffie Hellman keys instead of generating new ones \cite{return-false}.

Furthermore, the "Weakest link" problem still persists. If a device is incapable of establishing a secure-enough communication channel, the security is automatically downgraded. If \ac{BLE} security is the goal, it should be considered that some devices should be able to reject insecure communication. Of course, this may influence the user experience and has to be applied where appropriate. The NIST also supports the mandatory setting of highest possible security levels for Bluetooth \cite{nist}.

As far as key exchange is concerned, the pairing methods should be reevaluated. Especially the \textit{Just Works} method is, while it "just works", especially insecure, in particular in Legacy connections. While not all devices may be able to display or take input for numeric keys, it should be considered if certain devices could be enabled to use \textit{Out of Band} methods instead. To take a broad example, wireless headphones could receive the required keys in another manner. With the rise of \ac{NFC} implementation in smartphones, it may be possible to introduce \textit{Out of Band} exchange and authentication in this field, and perhaps in many other contexts as well.

As for iBeacons, there are a few suggestions to be made regarding their security. The first, and perhaps most obvious, is in regard to the public nature of iBeacon UUIDs. Implementations need to realize that UUIDs advertised by this technology are and will be public. It is perhaps a bit uncertain how this can be enforced on a specification or legislation level, but architectures developed around iBeacons or \ac{BLE} advertising technology need to take into account that any iBeacon placed is readable by all Bluetooth-enabled devices. Using iBeacons for use cases such as authentication is not recommended in any way.

Technologically speaking, a few things could be improved. Again, the first is concerning the public nature of UUIDs. It may be possible to produce iBeacon technology in a read-only manner. To take an example, \ac{NFC} Ultralight cards have an immutable ID and One Time Pad byte space. If such concepts could be implemented in the Bluetooth stack, cloning iBeacons may become significantly harder or perhaps even impossible. Currently, this may not be possible due to the fact that all Bluetooth-enabled devices can simply transmit iBeacon frames. Further research may be warranted here.

To improve the UUIDs, it might also be possible to enforce iBeacon specifications or implementations that rotate or even randomly generate new UUIDs periodically. There are already devices available on the market that implement this kind of behavior \cite{survey}. Of course, related software, for example the Apple Store application, would need to take this shifting into account. However, this is a small price to pay for increased security. This also partially solves the privacy-related issue. Unless the tracking application or device is also aware of the changed UUIDs, creating movement profiles or similar observations become more challenging.

The integrity of the configuration of iBeacons may be improved using established methods from other authentication-requiring technology. Processes such as two-factor authentication could further secure the communication with the configuration of iBeacons. Lastly, using a different technology channel, for example WiFi, to communicate with the iBeacon may also be warranted, as long as there is a reasonably secure way to communicate. Given that introducing a new technology stack to a small battery-saving device can be costly and perhaps too complex, this decision might be best left to the manufacturer of the device.

Both \ac{BLE} and iBeacons serve the purpose of creating low-energy, efficient communication or advertisement for the sake of user interactivity. However, both technologies show concerning flaws considering key exchange and identity advertisements. Given the introduction of specification 4.2, \ac{BLE} is taking steps in the right direction. However, implementations need to adhere to this specification more closely, and the specification itself should be refined to reflect higher levels of security. iBeacons have the problem of their inherently public nature, but there are concepts to improve, with some manufacturers taking this matter into their own hands. If this change could be reflected in the general structure of iBeacons and advertising Bluetooth devices, security- and privacy-related issues could be tackled more successfully.